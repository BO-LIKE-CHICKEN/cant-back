# 하나의 더미

## 요약

> 이제 더미가 커지면서 머릿 속에 형상이 떠오르기 시작합니다.
> 이제야 알았다. 먼저 이걸 계산하고, 그걸 이용해서 저것을 계산하자!
> `왜 아무도 그 이야기를 해주지 않았을까?` 이쯤 되면 책 제목에 있는 질문에 이르게 됩니다.
>
> **"Tidy First? 코드를 먼저 정리할까? 아니면 지금 눈에 보이는 것만 먼저 변경할까?"**

## 설명

개발에서 가장 큰 비용은 결국 "이해하는 데 드는 비용"이에요.

설령 제가 짠 코드도 1년이 지나면 알아보기 힘들 때가 많은데, 심지어 다른 팀원의 코드를 읽으며, 우리의 비즈니스를 떠올리기란 여간 쉬운 일이 아니에요.

하나의 더미는 이러한 환경에서 출발해요.

> 누군가 응집도 높게 작게 분리한 것이, 내게 항상 최선의 결과를 가져오는가?

차후 결합도에 따르는 비용과 결합도 제거 비용의 상충 관계(`chapter 31`)에서도 설명이 나오겠지만, 항상 결합도를 낮추거나, 응집도를 낮추는 일들이 최선의 결과를 가져오지 않아요.

따라서 때로는 흩어진 코드들을 한데 모으는 것이, 문제를 해결하는 데 큰 도움을 주기도 합니다. 어떤 상황에서 말일까요?

### 하나의 더미는 어색한 연결 고리를 찾는 데 도움을 줘요

자신의 프로젝트를 하나씩 떠올려 보고, 다음 질문을 생각해주세요.

> 혹시, 코드가 깔끔하게 잘 쪼개졌지만, 이해하기 어려웠던 경우는 없었나요?

예컨대 다음과 같은 경우에 말이죠.

- 코드가 함수에서 잘 동작하고 있는데, 함수를 호출할 때 인터페이스가 너무 불편했어요. 🥹
- 반복되는 코드가 있는데, 이를 추상화할 생각이 없었어요. 애초에 다른 모듈 구조에서 호출했기 때문에 반복된다는 느낌이 없었거든요. 🥲
- 헬퍼 함수가 A의 책임을 진다고 적혀 있는데, 알고 보니 여기서는 B의 책임을 지고 있지 뭐에요? 😡
- A라는 객체의 값이 다르게 나와서 디버깅해봤더니, C라는 모듈에서 불러오면서 데이터의 불변성이 깨져 있었어요. 😖
- 엥, TSDoc에서는 A 프로퍼티가 a를 의미했는데 알고보니 b라는 의미를 갖고 있네요? 🙁

왜 이러한 상황이 나왔을까요?  
이유는, 데이터와 동작을 핸들링하는 함수의 위치가 서로 멀리 떨어져 있기 때문이에요.

다른 데서 많이 사용하는 데이터나 함수일 수록, 기존의 코드를 유지보수하는 과정에서 적절치 못한 변경이 발생할 수도 있어요. 때문에 코드 품질 저하의 위험이 있는데요.

문제는, 이러한 코드들의 위치가 서로 떨어져 있다보니, 이 문제를 인식하기가 여간 쉬운 것이 아니에요.

> 잠깐 생각나는 예를 들어볼게요.
> 혹시, 코드리뷰를 완벽하게 받았다고 생각했는데 배포하고 나니 변경했던 함수가 다르게 적용되어 문제가 터진 적은 없었나요?

따라서 때로는 하나의 더미처럼, 이해하기가 어렵다 싶으면 잠시 한 번 더 모으는 것도 방법이에요.

일단 코드를 모아놓게 되면 다음과 같은 효과가 발생해요.

- 오, 필요한 코드가 가까이 있으니까 이해하기가 쉬워졌어... 아! 이게 문제였구나! 내가 잘못 사용하고 있었네.
- 내가 이 함수를 A디렉토리에 배치했는데, 생각해보니 B디렉토리에 배치하는 게 이해하기 더 편하겠는데?
- 이 함수는 사실 분리가 되는 게 맞았네! 내가 필요로 하던 역할이랑 달라. 따라서 그냥 아예 새로 도우미 함수를 추출하는 게 낫겠어!

그렇게 다시 코드에 대한 이해도는 높아지고, 우리는 좋은 코드를 만들죠.

그렇게 다시 동작을 이해하기 쉽게 변경한 다음에 스스로에게 물어보세요.

> `Tidy, First?`

## 1차 사유

저는 **우아한 퇴보**라는 말을 좋아해요. 개발에는 항상 이상적인 기술들이 존재하는데, 일부 사이드 이펙트가 발생하는 브라우저에 대한 배려가 느껴지니까요.

어쩌면 이 파트가 개발자의 우아한 퇴보가 아닐까 싶어요.

일반적으로 성능을 추구하는 업계 특성상, **항상 모든 것은 쪼개야 한다**는 강박관념이 존재해요.

그러다 보니 일단 쪼개고 보는데, 그러다 보니 다음과 같은 문제점이 있었어요.

1. 분명히 어딘가에는 상수나 함수가 있는데 못 찾겠어요. 그런데 MR에 보면 있다는데, 이때 자괴감이 들어요 🤣
2. 점차 변수에 대한 겹침이 심해졌어요. 예컨대 특정 도메인 별로 반복되는 상수 개념을 export한다던가 할 때 말이죠.

결국 이러한 것들이 쌓이다보니, 결국 잘못된 것들을 불러오거나, 반복되는 상수들을 만들게 됐어요.  
오히려 번들사이즈를 줄이고자 재사용성 높게 분리했는데, 번들링 과정에서 실질적인 메모리 상에서의 용량은 커지게되는 셈이죠.

따라서, 요새는 보통 객체로 묶어서 쓰는 편이에요.

페이지가 정적인 곳에서의 성능만 신경을 쓰고, 동적인 소스인 경우에서는 하나의 더미로 묶어서 표현하는 방법으로 말이죠.  
이렇게 사용하고 나니, 확실히 변수의 반복되는 부분이 줄어들고, 오히려 읽기가 편하더라구요.

## 2차 사유

다시 이 글을 꼼꼼히 읽어보았어요. 거의 30분이 지난 것 같아요.

그러고 나서야 어느 한 가지 저의 문제점을 포착했는데, 제가 너무 이 책에서 **하드 스킬**을 갈구했다는 것이었어요.

그렇기 때문에 **하나의 더미** 라는 제목에서, 구조적 관점에 매몰되어 행동학적 관점에서 이 글을 바라보지 못한 거에요.

그렇게 색안경을 바꾸고 나서, 이 책을 다시 읽기 전에 좀 더 개발자가 아닌 **문제를 해결하는 인간**으로서 저자의 의견을 수용해보려 노력했어요.

그랬더니, 조그만 어조와 문체가 또 다르게 보이더라구요.

어찌 보면 이 하나의 더미를 곱씹어보던 과정에서 얻은 기술적 지식은 적을지라도, 책 한 권의 영향만큼이나 중요한 무언가를 얻지 않았나 느껴졌기에, 기분이 좋네요!
