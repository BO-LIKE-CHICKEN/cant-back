# 새로운 인터페이스로 기존 루틴 부르기

## 요약

인터페이스가 간혹 어려운 루틴들은 코드 작성에도 힘들거니와, 이해하는데도 어려워요.  
따라서 이를 해결하기 위해서는, 새로 인터페이스를 만드는 방법이에요.  
이를 토대로, 설계에 대한 부담을 덜고, 점진적으로 변경할 수 있도록 해요.

다음과 같이 설계하면 더욱 쉬워요.

- 거꾸로 코딩하기: 루틴의 결과 코드를 먼저 확보하고 코딩하기.
- 테스트 우선 코딩: 테스트 코드를 먼저 작성하기.
- 도우미 설계: 헬퍼 함수가 있는지, 어떻게 설계할 것인지 확인 및 구상하기.

## 예제

### 포맷팅 함수 공통화하기

현재 사내에서는 꽤나 많은 포맷팅 함수들이 있어요.  
이 함수들은 결과적으로 특정 값들을 포맷팅하여, 다른 값으로 변환하는 역할들을 하죠.

예컨대 다음과 같아요.

```ts
formatMoney(10_000, "원"); // 10,000원
formatTanentDeposit(0, "세입자 보증금 없음"); // 세입자보증금 없음
formatDsr({
  dsr: 0.25,
  prefix: "DSR",
  isSpaceAfterPrefix: true,
}); // DSR 0.25
```

이러한 코드는 얼핏 문제점이 없어 보여요.  
하지만 장기적으로 생각한다면? 다음과 같은 문제점을 야기할 수 있죠.

#### 문제 1. 포맷팅에 대한 인터페이스가 일정하지 않아요.

코드를 사용하는 작업자 입장에서는 어떨까요?  
물론 코드는 짜여져 있으니, 함수가 어떤 식으로 구현되었는지 들어가서 확인해야 해요.

이는 문제가 되지 않지만, 이 장에서의 이야기를 인용하자면 다음과 같은 우려는 있을 것 같아요.

> 두 가지 이상의 패턴을 섞어 쓰면 혼란스러워집니다.
> 코드를 읽을 때 기존과 다르다면 '다른 동작의 코드겠지'라고 예단하겠죠.
> 여기서 차이가 있다 보니, 같은 일임에도 다른 일인 것처럼 뜻이 흐려집니다.

위의 3가지 함수를 보고, 만약 30가지가 생긴다면 어떻게 될까요?  
과연 우리는, 나머지 27개의 사용 방식을 확신하고, 예측할 수 있을까요?  
다른 사람들이면 몰라도, 저는 코드를 의심해서 들여다보고, 서로 다른 코드 패턴에 혼란스러울 것 같아요 😭

#### 문제 2. 어떤 방식으로 포맷팅 함수를 계속해서 짜야될지 고민이에요.

현재 코드를 생성하는 작업자 입장에서는 어떨까요?  
일단, 포맷팅에 대한 함수를 어떻게 짜야 타 작업자들이 편할지 고민하는 시간이 길어져요.

결국 이러한 피로도가 쌓이면 어떻게 된다면, 작업자들은 더이상 유틸함수를 쪼개고 싶지 않아요.  
왜냐하면, 함수를 쪼개고, 인터페이스를 고민하고 재사용하는 비용이, 그냥 코드를 복사하는 비용보다 크기 때문이죠.

#### 포맷팅 함수 공통화

우선적으로 위의 코드 중 `formatDsr`을 살펴볼까요?

```ts
export const formatDsr = ({
  dsr,
  prefix,
  isSpaceAfterPrefix,
}: {
  dsr: number | null;
  prefix?: string;
  isSpaceAfterPrefix?: boolean;
  defaultValue?: string;
}): `${string}%` | "-" => {
  if (!dsr) {
    return "-";
  }

  return `${prefix ?? ""}${isSpaceAfterPrefix ? " " : ""}${dsr.toFixed(1)}%`;
};
```

코드가 주어졌으니, 한 번 이 책의 권장하는 방식대로 거꾸로 코딩해볼까요?

결과 코드는 문자열이고, 문자열에 필요한 조건은 다음과 같아요.

- 대상이 되는 값이 들어간다.
- 값에 대한 필터링을 진행한다.
- 다른 문자를 넣어줄 수 있게끔 한다.

따라서, 생성 로직을 다음과 같이 루틴을 생성하여, 공통의 인터페이스를 따르는 루틴을 만들면 어떨까요?  
다음과 같이 말이죠.

```ts
import { Brand, BRAND } from "../constants";

export type Formatter = <T>(
  target?: T
  option: {
	  to: `${string}${Brand}${string}`,
	  filter?: (arg: T) => string
  }
) => string;

export const format: Formatter = (inputString, { to, filter }) => {
  if (!inputString) {
    throw new Error("format: 바뀔 문자를 정의해주세요.");
  }

  const str = filter ? filter(str) : inputString

  return formattedText.replace(new RegExp(BRAND, "g"), str);
};

format.brand = BRAND;

// 사용
format(money, { to: `${format.BRAND}원`, filter: filterCommaNumber })
format(deposit, { to: deposit ? `${format.BRAND}원` : '세입자 보증금 없음' }); // 세입자보증금 없음
format(dsr, { to: `DSR ${format.BRAND}` })
```

이렇게 유틸 생성 루틴을 함수화한다면, 어떤 효과가 있을까요? 적어도 다음과 같은 효과가 있을 것 같아요.

1. 포맷팅 함수의 생성 로직을 일관성 있게 유지할 수 있어요.
2. 필터링 동작과 포맷팅 동작을 구분하여 함수를 만들게끔 강제함으로써 더욱 응집도 높은 코드를 만들 수 있어요.

따라서, 현재는 해당 인터페이스를 구현만 하고, 사내 아이디어를 제시한 상태에요.  
이러한 인터페이스를 당장 강제하지 않아도 괜찮아요.  
결국, 통로 인터페이스만 만들어낸다면 편한 인터페이스는 계속해서 쓰게 되어있고, 레거시 코드들은 우리가 편한 함수로 서서히 리팩토링할테니까요.
